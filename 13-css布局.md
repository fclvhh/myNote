# 浮动基础

## 为什么需要浮动？

1. 文字围绕图片

2. 水平排列布局



①文字围绕浮动元素  展示

[文字围绕图片](http://js.jirengu.com/moguk/1/edit?html,css,output)



## 浮动基础

①定义

- float属性能让一个元素放在其容器的左侧或右侧，允许文本和内联元素环绕它。设置浮动的元素从网页的「普通流」(normal flow)中**脱离，但不是完全脱离**

②特性

- 一个浮动元素会向左或向右**移动**，直到其外边（outer edge）「挨到**包含块」**【边沿】或者另一个浮动元素的【外边】。ⅰ如果存在**行盒**([行盒介绍](https://blog.csdn.net/weixin_42661269/article/details/100401396))，浮动元素的外top（边）会与当前行盒的top（边）对齐ⅱ如果没有足够的水平空间来浮动，它会向下移动，直到位置合适
- 因为浮动元素**不在普通流内**，在浮动盒之前或者之后创建的未定位的（non-positioned）块盒会竖直排列，就像浮动不存在一样。然而，浮动元素之后的行盒会**进行必要的缩短**，为了给浮动元素的margin box**让出空间**  [让空间](http://js.jirengu.com/qupor/2/edit)



## 普通流

①什么是普通流

- 就是元素在正常情况下默认的摆放规则
- 块级元素宽度撑满父亲、高度由内容撑开，可以设置宽高。按照在HTML里的**顺序**从上到下排列，会出现**边距合并**
- 内联元素的宽高**与内容一致**，无法设置宽高，只要有足够空间就会在一行排列，如果空间不够会下移一行

②什么是脱离普通流

- 就是元素不按默认规则摆放了，其他**正常元素在「计算自己的摆放位置」**时不把脱离普通流的元素包括在内







## 浮动特性演示

①不浮动的情况

- [不浮动](http://js.jirengu.com/vuvap/1/edit)

- 普通流的摆放规则

②浮动的情况

- 一行「放不下」会下移
- 子元素脱离普通流，父亲无法发现浮动元素存在，高度为0 「高度塌陷」
- [放不下](http://js.jirengu.com/jogac/1/edit)

③被卡主

- 率先浮动的元素卡住了后面的元素
- [卡住](http://js.jirengu.com/mimaj/1/edit?html,css,output)

④对周边行内元素的影响

- 虽然普通流的元素当浮动的元素不存在,但是一旦「重叠相遇,」还是会环绕的
- 块盒看不见浮动的box1，但是〔**文本能看见**〕
- [文本看见](http://js.jirengu.com/jogac/1/edit)

⑤浮动元素宽度是收缩的

- 浮动的块级元素，宽度收缩
- 不再是独占一行
- [宽度收缩](http://js.jirengu.com/lefeh/1/edit)

⑥浮动元素呈现块级特性

- 浮动的行内元素可以设置宽度、高度、内外边距
- [设置了宽度](http://js.jirengu.com/kosoq/1/edit)





# 浮动深入

## 浮动的使用场景

①两栏布局

- **左侧**固定宽度，右侧字使用
- [示例](http://js.jirengu.com/tinec/1/edit?html,css,output)
- **右侧**固定宽度，左侧自适应
- [示例2](http://js.jirengu.com/yecol/1/edit?html,css,output)

②三栏布局

- 简单的三栏布局
- [案例](http://js.jirengu.com/siqax/1/edit?html,css,output)

③导航条

- 左浮导航条
- [导航](http://js.jirengu.com/moyod/1/edit)
- 右浮导航条
- DOM顺序不变
  - ul右浮动,li左浮动
- [导航2](http://js.jirengu.com/wuvab/1/edit)



## 浮动副作用

①对后续元素「位置」产生影响

〖本质〗是因为: **浮动元素会让文字产生环绕效果,迫使含文字的「行盒元素」也跟着移动and变化**

- [副作用1](http://js.jirengu.com/qupor/1/edit)

![](assets\浮动副作用.jpg)

②父容器无法包裹子元素

- [高度塌陷](http://js.jirengu.com/zucoh/1/edit)
- li浮动导师ul高度塌陷,进而导致navbar高度塌陷
- 本质: 普通流中的块盒元素会被行盒元素撑开,这是**普通流的特性** 
  - 子元素脱离的普通流,没人撑开,导致塌陷



## 清除副作用

> 让父亲「**包裹**」浮动子元素，减少对其他元素的影响

如: ul包裹li,减少对navbar的影响

①clear元素

- **clear:left**   「我的左边不可以有浮动元素,如果有,我就滚下去」

- 要求该盒的「top border边」位于源文档中在此之前的元素形成的所有左浮动盒的底边下方

- 换句话说: 第二顺位的浮动元素的top border 在第一顺位左浮动元素的 bottom border 下面

  [示例](http://js.jirengu.com/wenak/1/edit)

  box2清除了box1左浮动的影响

  ⒈box2和box1同级别,所以不能忽视

  ⒉根据浮动的规则: 本应该排在box1后,但是清除这个规则的影响

  ⒊本身是左浮动, 与box1同级,所不能无视,又不能按照浮动规则,就产生了示例的效果

- **clear:right** 「我的右边不可以有浮动元素,如果有,我就滚下去」

- 要求该盒的「top border边」位于源文档中在此之前的元素形成的所有右浮动盒的底边下方

- 同理

- **clear:both** 「我的左边和右边不可以有浮动元素,如果有,我就滚下去」   就不能和你们同一行!!!

- 要求该盒的「top border边」位于源文档中在此之前的元素形成的所有左浮动盒和右浮动盒的底边下方

- 无论左右浮动,一律清除



②注意

- **移动的对象是自己**，不是其他元素



③清除浮动

- 固定套路代码

```css
.clearfix::after {
    content:'';
    display:block;
    clear:both;
}
```



[解决副作用1](http://js.jirengu.com/jidud/1/edit)

思路:

1. `content :" "  ;   display:block;`  父元素里塞了一个伪元素
2. `clear:both;`  让伪元素所在行,不存在其他的浮动元素, 避免了下面的元素文字被浮动环绕引发的bug
3. `clear:both;` 同时让伪元素必须在浮动元素的下方, 所以 高度也就相应的被撑开了



[解决高度塌陷](http://js.jirengu.com/dejiy/1/edit)

由前面分析很简单





# 定位基础

## 为什么需要定位?

1. 改变元素的「位置」

2. 让元素「重叠」放置任意位置

3. 让元素「固定」在窗口固定位置

**新的布局方式可以取代浮动,但是却不可以取代定位!**



■〖一个简单的案例〗

```css
.box {
    position:absolute;
    top:10px;
    left:10px;
    z-index:1;
}
```



■〖定位涉及到的元素〗

- position：static、relative、absolute、fixed、sticky  「定位方式」
- top、left、right、bottom   「位移坐标」 
  - 四个角分别对应四个组合   如:「左上角--top 和left」
  - **重要:位移坐标的性状和margin(包括负边距)的是如此的相似**
  - left:10px是自己的外边距相对于参考元素的边框内壁偏移10px
    - **正值代表  靠近**
    - **负值代表  远离**
- z-index  「层叠等级」



## position细节

①position:static   「格式化的功能」

- 该关键字指定元素使用正常的布局行为，即元素在文档常规流中**当前的布局位置**。
- 此时top,right,bottom,left和z-index属性无效
- 日常所说的定位元素不包括 position:static

②position:relative

- 让对应的元素做**轻微的位移**「没有脱离普通流」
- 常见的场景: 图标位置没对齐

③position:absolute

- 不为元素预留空间「**潜台词:脱离普通流**」，通过指定元素相对于最近的【非static定位】〔开启定位,值不是static就可以〕**祖先元素**〔参照物〕的偏移，来确定元素位置。

  - 为了满足absolutely参照物的限定

  - 因此经常出现   **父相子绝** 的布局场景

  - **如果忘记设置参照物, 默认以 html作为参照**

- 绝对定位的元素可以设置外边距（margins），且**不会产生边距合并**

  - 开启了定位,在普通流中连位置都没有的,还合并个鬼啊
  - magin的作用早就被 top left ... 等属性取代了, 谈何外边距合并

④position:fixed

- 不为元素预留空间「**潜台词:脱离普通流**」，而是通过指定元素相对于**屏幕视口（viewport）**〔参照物〕的位置来指定元素位置。**元素的位置在屏幕滚动时不会改变**。打印时，元素会出现在的每页的固定位置
- [屏幕视口](https://juejin.im/post/5bb6c62be51d450e47142c60):就是显示器的大小

⑤position:sticky  「更高级的功能」

- sticky定位可以被认为是「相对定位」和固定定位的**混合**。
- 元素在跨越特定**阈值**前为相对定位，之后为固定定位



# 定位使用场景

## ①相对定位 relative

- 轻微的位移
- 场景 : 微调图标
  - [微调前](http://js.jirengu.com/zekif/1/edit)
  - [微调后](http://js.jirengu.com/deyom/1/edit)
- 优势 : 不会脱离普通流,也不会影响其他元素的位置
- margin也可以做到类似的效果, 和relative比较的缺点
  - 会对后面的元素的布局产生影响
  - relative的补救效果更好

## ②绝对定位absolute

- 适用出现**元素重叠**、**放置任意位置**的场景
- 也是最常用的定位
- 场景
  - [实现搜索框](http://js.jirengu.com/wacem/1/edit)
  - [实现模态框](http://js.jirengu.com/gisem/2/edit)    ⒈注意垂直水平居中的实现  ⒉纯CSS实现模态框
  - [实现Tooltip效果](http://js.jirengu.com/lugoz/1/edit)

### **〖常用代码〗**

⑴撑满父亲

```css
/*撑满父亲*/
.box {
    position:absolute;
    top:0;
    left:0;
    bottom:0;
    right:0;
    /*width:100%;height:100%;*/
}
```

⑵垂直水平居中

```css
/*垂直水平居中*/
.box {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    /*向左、上移动自身宽高的一半*/
}
```

⑶Tooltip

```css
.tooltip {
    cursor:pointer;/*鼠标变成手指点击的形状*/
    top:calc(100%+10px);/*注意calc的括号里面的空格不能少*/
}
```



## ③固定定位fixed

- 适用需持续**固定在浏览器某位置**的场景
  - 如企业站窗口底部的“联系我”、
  - 某些固定在页面顶部的**导航条**



## ④粘性定位sticky

- 标题随页面滚动，到顶部固定
  - [标题被“覆盖”的效果](http://js.jirengu.com/coguv/2/edit?html,css,output)
  - [标题被“推上去”的效果](http://js.jirengu.com/qanux/1/edit)



# 定位使用的经验总结

## **相对定位**

特性

- 未脱离普通流
- 元素本身在普通流中的**位置并未发生变化**，只是**视觉上变化**
- 注意和负margin的区别的

## 绝对定位

特性

- 一定要有参考点，一般需给父亲设置position:relative，对父亲本身没影响，但作为自己的参考点  「**父相子绝**」
- 绝对定位元素**完全脱离普通流**，其它元素(包括父元素)无法发现绝对定位元素的存在，绝对定位元素会出现**相互覆盖**情况
  - 绝对定位的元素互相之间**无法感知**,自然位置就可能发生重叠
- left:10px是自己的**外边距**相对于参考元素的**边框内壁**「内边」偏移10px。
- 如果不设置left/top，或者设为auto，则绝对定位元素的位置处于**默认位置**(不设置绝对定位时的位置)
- 绝对定位元素的宽度是**收缩**的，**一般需要设置固定宽度**
  - 比如 div 一旦设置了绝对定位,就脱离了普通流,失去了「块盒」的特性【独占一行】
  - 所以需要设置width
- **给行内元素设置绝对定位后就有了「块级的特性」，可以设置宽高**



## 固定定位

特性

- 相对于浏览器窗口
- **一定要设置top/bottom**，否则可能出现无法展示的情况
- [固定定位消失](http://js.jirengu.com/nabet/1/edit)



## 粘性定位

特性

- 一定要**设置top**
- 当页面向下滚动时，被视窗顶部**拦住**，被父级块元素的下边缘**推走**
- 如果出现多个sticky，放置在**同一容器内**，会出现下一个sticky元素把上一个“覆盖””的效果
- 如果出现多个sticky，放置在**并列的多个块级容器内**，会出现下一个sticky元素把上一个“推走”的效果





# 层叠上下文

## 为什么要有这个概念

1. 对于定位元素，重叠产生时，**覆盖顺序**是怎样的？

2. 重叠产生时是z-index越大越靠前吗

## Stacking Context  

> 中文翻译：层叠上下文
>
> “上下文”一般理解为：
>
> 1. 一个多方参与构建的、遵循一定规则的、独立的环境；
> 2. 子项可能创建新的上下文，与外层上下文有同样的规则，且与外层上下文隔绝

上下文图示

![](assets\层叠上下文.jpg)

## 层叠上下文形成条件和规则

①形成条件

- 根元素(HTML)
- z-index不为auto的绝对定位和相对定位元素
- fixed定位元素和sticky定位元素
- z-index不为auto的flexitem
- z-index不为auto的griditem
- opacity小于1的元素
- transform不为none的元素
- 其它不常用的



②层叠规则

- 属于同一层叠上下文的同级元素比较  
- 当层叠上下文属于某一层级时，其内的层叠上下文都属于对应层级

小结

1. z-index是同层比较的手段
2. html作为根元素开启上下文,按照规则比较元素的层叠关系
3. 之后以开启增得上下文的元素作为"根元素" ,处理自己的子元素
4. 以此类推



## 其他场景分析

①没设置z-index的场景

[案例](http://js.jirengu.com/luvon/1/edit)

顺序

- 根元素的背景和边界
- 普通流(无定位)里的块元素(没有position或者position:static;)按HTML中的出现顺序堆叠
- 定位元素按HTML中的出现顺序堆叠

[设置z-index](http://js.jirengu.com/cemus/1/edit)

能否得出z-index越大越靠前的结论?

不能,这是错的

②带浮动的场景

顺序

- 根元素的背景与边框
- 位于普通流中的后代块元素按照它们在HTML中出现的顺序层叠
- 浮动块元素
- 后代中的定位元素按照它们在HTML中出现的顺序层叠

![](assets\浮动层叠图.jpg)



# 块级格式化上下文BFC

## 为什么?

Block Formatting Context

> 块级格式化上下文，简称BFC
>
> 上下文”一般理解为：
>
> 1. 由多个子项参与构建的、遵循一定规则的、独立的环境；
>
> 2. 子项可能创建新的上下文，与外层上下文有同样的规则；
>
> 3. 新上下文中的子项与外层上下文的子项隔绝
>
> **块级格式化上下文：块级元素参与构建的、遵循一定规则的独立环境**



图片介绍

![](assets\BFC图片.jpg)



## BFC形成条件和特性

### BFC形成条件

形成条件

- 根元素`<html>`
- float属性不为none；
- position为absolute、fixed、sticky
- display为inline-block、table-cell
- display:flow-root或者flow-rootlist-item
- overflow为hidden、scroll、auto；

推荐使用display:flow-root，没有副作用 「目前兼容性不好」

### BFC特性

特性

- 内部的块级盒子会在垂直方向，一个接一个地放置。
- 两个盒子垂直方向的间距由margin决定。属于同一个BFC的两个相邻盒子的外边距会发生折叠。
- BFC的区域不会与浮动盒重叠。
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
- 计算BFC的高度时，浮动元素也参与计算

   