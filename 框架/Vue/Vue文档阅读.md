# 介绍

## 声明式渲染

**本质: 模板字符串替换** 只不过标识符号固定成 `{{}}`

```js
var　html = `
	<P>{{xx}}</p>
`
html.replace({{xx}},data.xx) 
```

内部做了这些事



## 条件与循环

> 结构切换 , 决定结构是否展示

思路:

1. 用js调整display的属性值
2. 用js控制DOM结构



v-show : 将数据绑定到DOM属性 display 上  **可以算是v-bind的语法糖**

v-if : 将数据绑定到DOM的结构上 , 决定结构是否存在



小结:

​	==**Vue可以把数据绑定到文本上 , 属性上 , DOM结构上**==



> 将数组数据展示到列表里

不用数组的forEach方法 , 采用v-for一键生成

**本质:**  还是使用forEach(()=>{})

这就是为什么v-for里面的三个参数正好时 forEach()里面回调的三个参数

item , i  , this

 

## 处理用户输入



事件监听

1. 创新一 : 把事件与元素的绑定写到了对应的元素上 , 省去了获取元素在绑定事件的过程
2. 创新二 : 事件回调 统一写在methods对象 ,完成**自动化绑定**



## 组件化应用创建

- 任意类型的组件都可以抽象成一个组件树
- 组件的本质 : 一个拥有**预定义选项**的一个Vue实例
- 常见组件树模板

```shell
根实例
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics
```

 		有一个根实例 , 根实例下面有一个根组件 , 根组件下面按照树的规则展开

- 组件类似于自定义标签 , 但又不完全相同
  - 跨组件数据流 「这里主要是父传子的通信方式」
  - 自定义事件通信「主要是子传父 , 也是单向绑定的核心思路」
  - 构建工具集成 「.vue三段式文件」







> 举例说明 : 组件传值

```html
<div id="app">
     <ol>
    <!-- 创建一个 todo-item 组件的实例 -->
      <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
 </div>
```

要点说明 : 

1. 组件传值格式

```html
<todo-item :todo="item"></todo-item>
```

​	todo是子组件的Props选项的参数名 , 绑定了父组件传下来的值item

​	在子组件的属性上传值



```js
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var vm = new Vue({
  el:"#app",
  data:{
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})
```





# Vue实例

- Vue的实例 , 常命名为vm (ViewModel 的缩写) , 也就是MVC中的View视图层的缩写



## 数据与方法

- data对象中的所有属性加入Vue的响应式系统
- 提前设计初始值的目的就是为了加入响应式



## 阻止响应式系统的追踪

`Object.freeze()`



## 生命周期钩子函数





# 模板语法

## 插值

- 胡子语法会将数据解释成普通的文
  - 那么想插入html 结构怎么办?
  - v-html
- **插值的方式 , 将决定数据的解释方式!!!**
- 插值 : 就是数据绑定

### 数据作为文本

​	**一次性插值** v-once指令



### 数据作为html结构

​	数据 

```js
let rawHtml = `<span style="color:red">哈哈</span>`
```

​	插入

```html
<p>只有我一个人想笑吗 {{rawHtml}}</p> //这是错的
<p>只有我一个人想笑吗 <span v-html="rawHtml"></span></p>
```

v-html执行: 

- 会替换掉 依附的span标签
- 在span标签占位处 , 换上rawHtml代码



### 数据作为属性



- 属性的分类

  - 值属性  :  属性的值是非布尔类型的数据
  - 布尔属性 : 属性的值是布尔类型的数据

  



### 数据作为js表达式

```js
{{n++}}
```

n : 是数据

n++ : 是js表达式

js支持所有的表达式 , 但不支持语句

 如 : 

```js
var n = n++   
```



## 指令

- Directives  
- 指令是特殊的自定义属性
- 指令的值 : 单个js表达式
- 指令的作用 : js表达式的值改变时 , 将其产生的影响 , 响应式的作用于DOM



### 参数



- 一些指令可以接收参数
- v-bind:href = “value”
  - 指令将 href属性 和  value 扳道工

### 动态参数



v-bind:[xxx] = “yyy”

xxx: 可以是一个js表达式



### 修饰符

v-on.xxx

事件绑定修饰符





# 计算属性和侦听器



## 起因

{{js表达式}} 的应用在写代码的过程中逐渐多了起来

这种写法每次视图更新的时候 , 不管js表达式中用到的data里面的属性值是否改变

都需要重新计算 

换句话说 : 没有缓存 , 效率不高



所以就为类似的表达式 , 添加了缓存 , 用computed选项来管理



## vs 方法

计算属性本质上 : 是js表达式 , 是一个值

被set/get 模仿成一个属性 , 所以称为计算属性. 又结合ES6的语法 , 以及set()的省略

因此 , 直观上和方法很像   其实是不同的两个东西 , **方法是事件的回调**

**计算属性本质上是一个js表达式**



## vs 侦听属性

本质 : 响应式的区别



计算属性 : 

​	js表达式 中的算子是响应式系统的 , 因而表达式的值也自然是响应式的

watch：　

​	自定义的响应式，原理和Vue的一样

​	只是在可以自己写,notisfy方法



小结 : 计算属性好用点

1. 不是命令式
2. 不重复





## 计算属性的setter

> 经典案例

计算属性的getter+setter  配合 v-model   实现全选的功能





## 侦听器watcher

自定义响应式





# Class 和 Style的绑定

改 : 

1. Class
2. Style
3. 结构



## 对象语法

> 决定值是否存在

{x:y,}

x是否存在 , 由y的真假决定



## 用在组件上

在父组件看来 , 子组件只是一个自定义标签而已





# 条件渲染



## v-if 配合template标签

- 指令作为属性 , 必须写在标签上
- template标签作为 , 占位符
- 指令解析后  , template标签会自动销毁 , 渲染结果不包括template标签



## v-else



## v-else-if



## 用key管理可复用的元素

- Vue会尽可能的复用已经存在的元素 「就地复用策略」
- 但不想Vue复用时 , 需要给相应的元素添加上 key属性



# 列表渲染

## 维护状态

v-for渲染列表时 , 默认采用"就地更新"策略

1. 不会移动DOM元素
2. 当数据顺序发生改变时 , 就地更新视图 , 重新渲染



这是Vue的默认处理方式 , 但是不适用于所有的情况

- 依赖子组件的数据
- 依赖临时DOM的数据

这些情况下 , 需要增加key属性



## 数组更新检测

> 响应式的bug

`Object.defineProperty`(obj,“key”,{})

需要三个参数 : 

1. obj
2. 对象属性的key名
3. 属性重写的功能增强配置 Option



其中第二个 , 必须要属性的key值 !!! 是bug的根源



1. obj ==> data 对象
2. key ==>data里面的名字

所以,如果开始的时候没有在data里面初始化好key , 是无法响应式的



解决: set() or $set



> 数组没有key 咋办???

用数组变异解决, 使用的是Vue自己写的数组API

用这些api操作 数组 , 数组也会支持响应式



### 替换数组

数组的高级api , 可以无障碍的使用



### 数组常见bug

- 你利用索引直接设置一个数组项, 无法响应式
- 你修改数组的长度 , 也无法响应式

解决思路 : 

Vue.set()

splice()

[数组注意事项](https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)



​	

# 事件处理

## 事件机制

> 步骤

1. 添加事件监听
2. 绑定事件回调

> 实现

1. v-on 完成事件监听
2. v-on:事件= “方法名”   完成事件绑定 
3. 回调方法在methods 选项中

> 运行机制

1. 解析指令v-on , 把对应的元素 , 获取DOM , 添加事件监听
2. 根据解析的方法名 , 去遍历methods对象 , 找到对应的函数 , 进行绑定



> 事件回调的处理细节

1. v-on 需要的是方法名 ,  如果方法需要参数怎么办?

```html
<input v-on:click = "sum(a,b)">
</input>
```

2. 如果需要用到事件对象 , 怎么表示?

```js
$event 标识原生的event
```







## 事件修饰符

> 事件流程

1. 事件三阶段
   1. 捕获
   2. 触发
   3. 冒泡
2. 事件可以在任意一个阶段触发 , 也可以选择是否继续向上冒泡
3. 事件触发了 , 但是也可以阻止其他元素的回调



> 修饰符 , 就是用来完善事件流程细节的

| 修饰符   | 作用                                |
| -------- | ----------------------------------- |
| .stop    | 停止冒泡                            |
| .prevent | 阻止默认事件                        |
| .capture | 捕获阶段触发                        |
| .self    | 事件是自己触发的 , 而不是冒泡上来的 |
| .once    | 事件只会被监听一次                  |
| .passive | 被动的 , 浏览器默认机制优先         |



## 键盘事件和鼠标修饰符



# 表单输入绑定









# 组件化

## 定义

> 概述

1. 组件是可复用的**Vue实例** , 并且带有名字
   1. 接收相同的Option
   2. 仅仅el , 这个根实例特有的 不同
2. 在 `new Vue` 创建的Vue根实例中 , 作为**自定义元素**使用
3. 组件可以被复用
   1. data选项必须是函数 , 返回一个 { } 
   2. 因为每个Vue实例都应该维护自己的数据



## 创建并注册组件

> 要点

1. 要被父组件识别
2. 作为`Vue实例` , 要有自己的名字 , 和 Option



> 步骤

1. 先创建  「生孩子」
2. 后注册  「注册户口」

> 组件名命名规则

1. 大驼峰
2. 小写杠



### 创建并注册全局组件api

```js
Vue.component("起名",{对象参数})
```



### 创建并注册局部组件 Option

```
component:{
	"起名" : {孩子},
}
```

ES6优化

```js
const "名字" = {孩子}
component:{
    "名字",
}
```



### 基础组件的*自动化*==全局注册==					

> 案例 , 跟着操作走一遍流程













> 单个根元素

每个`template`,必须有只有一个根元素 

换句话说 : html模板 , 必须保证**树结构**





## 组件传值 , 数据传递

### 父传子



Prop : 在组件上注册自定义属性

当值传给Prop定义的属性  ,  那么这个属性就注册成功了 



> 步骤

1. 注册自定义属性
2. 往属性传值

> 样例

```html
<div id="app">
    	// 给自定义属性赋值
	<haha :title="msg"></haha>
</div>
```

```js
const vm = new Vue({
    el:"#app",
    data:{
        msg:"只有我一个人想笑吗!"
    },
    components:{
        "haha":{
            // 注册自定义属性
            props:["title"],
        }
    }
})
```



> Prop的命名规则

- 优先考虑小写杠 命名

理由:

1. html不区分大小写
2. 浏览器一律转换成小写
3. 所有小写- 形式 加已区分



> Prop值类型

对注册的自定义属性 的类型 进行限定



> Prop 类型验证

值的限定加强版本



> 属性合并

1. 父组件 , 往子组件绑定class 属性
2. 子组件 , 内部模板也有class属性
3. 这个class属性 , 会合并到子组件模板的根元素上



**如果不是** class属性 , 却发生这样的情况 , 那么就会发生属性 替换

父组件给子组件绑定的属性 , 会替换掉子组件模板原本有的属性





> 属性合并的禁用







### 子传父



自定义事件系统

1. 父 : 绑定自定义事件 , 等待被子组件触发
2. 子 :  按钮事件触发 , 执行回调 , 回调中触发 自定义事件



通过事件系统机制 , 来完成数据的传递



## 自定义事件

### 事件名

正常的小驼峰命名就可以了



### V-model的双向绑定的增强



### 原生事件的绑定

> 介绍

把原生事件 , 绑定到组件的根元素



.native 修饰符

- 使用案例
- 注意事项



## .sync修饰符

> 暂时理解成一种语法糖!   快速双向绑定的语法糖

当父子组件 , 存在双向传值 , 并且是对一个父组件本地data一个属性的修改

就用.sync , 来表示这个相应的流程

```html
<text-document v-bind:title.sync="doc.title">
</text-document>
```

表示 , 父组件的  title 属性和子组件<text-document> 双向绑定了

- 子组件可以拿到title值
- 子组件修改title值 , 父组件的data对应的属性也跟着变







## 组件发散思维

> 谈谈双向绑定

1. 用户数据和html的绑定
   1. 用户数据通过Ajax拿到 , 存储到data选项中 , 加入响应式
   2. 由响应式系统 ,完成模板字符串替换 , 和模板渲染
2. UI数据「html」和 响应式系统的绑定
   1. UI数据不是持久化的数据 , 刷新页面就会消失
   2. 如何完成UI数据的暂存问题? --自然是`dataOption`绑定!
   3. 通过自定义事件机制,把UI数据作为事件回调中的参数 , 通过event对象拿到 , 赋值给data对象中的一个属性就可以了



> 手动模拟v-model

- v-model实现双向绑定

```js
<input v-model="UserText">
```

- 自己实现

用户数据和页面绑定

```js
<input :value="UserText">
```

ui数据和data绑定

```js
<input :input="UIdataHandle()">
   
UIdataHandle(e) {
    this.Userdata=e.target.value
}
```





> 从双向绑定来看组件传值

1. 首先明确一点 : 子组件在父组件看来就是**自定义标签** 
2. 父子组件这个系统里面 : 
   1. **父组件就是根组件,里面的数据就是用户数据**
   2. **子组件就是标签「是不是就相当于input标签!!!」 , 里面的数据就是`ui`数据**

3. 那么组件传值思路 --就是数据双向绑定的套路
4. 来看看`Vue`根组件是如何实现的?

```js
new Vue({
    el:"#app",
    data: {
        Userdata:undefined
    }
})
```

​		传值

```html
<input :value="Userdata"
       :input="UIdataHandle"
       >
```

5. 父子传值
   1. 父组件 : 通过自定义属性Prop 像子组件传值
   2. 子组件 : 通过触发自定义事件, 像父组件传值





## 数据绑定思路总结

- 用户数据和页面的绑定

本质 : 模板字符串替换 , 模板更新

> 绑定方案: 

1. 把数据拿到 , 放到data选项中 , 加入响应式 . 当数据发生变化时 , 自动的模板替换和更新
2. 指令其实就是语法糖 , 本质是**模板字符串占位** , 智能模板替换



- UI数据加入响应式

本质 : 事件机制 , 通过回调的event对象传值

> 绑定方案

1. 绑定事件 , 当事件触发时 , 在回调中拿到ui数据 ,  放到data中
2. 由于子组件是自定义元素 , 所以也需要自定义事件, 事件的触发不是浏览器负责的 , 变成js手动触发「当然源头肯定来自于浏览器内置事件提供动力」 





## 插槽分发内容

> Vue的几个内置标签

| Vue内置标签 | 功能                                    | 说明                                          |
| ----------- | --------------------------------------- | --------------------------------------------- |
| <template>  | 组件的html模板                          | 把template选项中的模板string结构抽离          |
| <slot>      | 相当于把组件作为根,调用`innerHtml ` api | 1.innerHtml = " " ,2.  innerHtml = `slot内容` |
| <component> | 组件动态切换                            | 配合is 属性使用 , 实现类似选项卡的效果        |

### slot机制解读

- 非常类似于修改DOM内容的操作

步骤:

1. 获取DOM节点 ,xx
2. `xx.innerHTML` = " "  清空原本内容
3. `xx.innerHTML` = "`newHtml`"    书写新的内容

- 示例

```html
<son>
    `只有我一个人想笑吗?`
<son>
```

son组件

```js
new Vue({
    el:"#app",
    data:{
        
    },
    components:{
        "son":{
            template:`  <h3>
							<slot>原本的html</slot>	
						<h3>`
        }
    }
})
```

最终展示结果

<h3>只有我一个人想笑吗?<h3>

### slot进一步理解

- slot 就是那个DOM xx , 我们自动获取了
- slot标签里面的内容就是 oldHTMNL
- 父组件传进来的 模板 , 就是 newHTML
- 素材具备后 , 一切过程都是自动完成的



### `Vue`自身细节问题

> newHtml的作用域问题

- 因为newHtml也是Vue语法的模板 , 肯定设计到Vue指令等语法
- 那么当用到了数据 , 到底去父组件data去找 , 还是去子组件的data?

规则:

​	父组件修改子组件DOM内容的 , 所以作用域 , 理应是父级

> slot 元素的特有属性

| 特有属性  | 作用                                       |
| --------- | ------------------------------------------ |
| name 属性 | 当有多个slot标签时 , 就用name来获取对应DOM |
|           |                                            |
|           |                                            |

> 多个slot 

1. 对应多个DOM元素 , 需要区分
2. 多个`newHtml` , 也需要知道应该替换谁的!

解决 : 

​	slot 起名 : name属性

​	`newHtml`: 注好对应的slot   「v-slot指令(正好可以利用template内置标签)」

格式

```html
<template v-slot:slotName>
    newHtml
</template>
```



> `newHtml `如何使用子组件的数据?

**插槽Prop**

- 正常Prop的逆过程
  - 子组件正常使用数据
  - 

格式

```html
// 插槽用到了子组件的数据
<slot v-bind:user="user">
    {{ user.lastName }}
 </slot>
```

```html
<template v-slot:slotName>
    slotName.user.xxx
</template>
```



## 动态组件

1. <component> 标签用来为子组件占位
2. is属性绑定标签名 , 决定<component>标签占位处 , 究竟是那个子组件组件
3. 点就按钮会修改修改`currentXX` 「"上课抢答"」



### keep-alive 状态缓存

用法

```html
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```



### 异步组件

组件异步加载

举例抄袭案例 , 先把功能跑通



### 处理边界 –- `Vue`规则调整

> 为什么称为边界

绝大多数情况下 , 不要用这种方式操作/访问DOM 

**因为很可能造成数据流向的混乱**

> 特殊的Vue边界接口

| 特殊            | 功能                                                         |
| --------------- | ------------------------------------------------------------ |
| $root           | 获取根组件, 是一个全局store , 被`Vuex`取代                   |
| $parent         | 访问父组件  「子组件具备了直接修改父组件数据的能力」 **不建议使用** |
| ref 属性和$refs | 访问对应的子组件 $refs: 子组件的数组   ref:取名 –- 找到对应的子组件 |
| $el             | 直接访问DOM元素  ,  可以调用`webapi` 操作                    |
|                 |                                                              |



> 依赖注入

背景 : 组件深层次的嵌套 , 此时底层组件 , 想要访问祖先组件 需要

```js
this.$parent.$parent.$parent....
```

会非常繁琐!!!



> 依赖注入选项

provide 和 `injex`[^注入]

provide : 提供   祖先组件使用这个选项,给后代提供公用属性

injex : 后代组件 , 可以用这个选项 , 注入公用属性 , 直接使用



> 小结 : 

所有的边界接口 , 都是为了解决数据流向问题提供的解决方案

但是数据流向的管理问题 , 早就有了一套管理方案 Vuex





### 边界处理之手动监听

背景 :  Vue事件采用的事件监听写在html上

那么 , Vue也提供了在js中添加监听的代码

> 步骤 

1. 在生命周期的挂载阶段
2. $on("事件名",回调 )

> 示例

```js
mounted:function() {
    this.$on("click",function() {
        console.log("hi")
    })
}
```



> 应用: 用来加载和销毁第三方库or插件

1. 在DOM挂载时 , 创建好第三方实例对象
2. 在组件销毁前 , 销毁第三方实例对象



最佳方案: 利用手动监听机制完成

解决了 , 实例对象需要被共享到data中的麻烦



## 组件的循环使用





## 解析DOM模板的注意事项

**is属性的使用**

is=“组件名”  用来展示组件







# 过渡和动画

## 概述

<transition>内置属性

- 会将内部包裹的元素自动添加css过渡/动画效果



## 实现思路

- 一个动画分为两个过渡
- 一个过渡有三个个动画帧
- 每个过渡都有3个class进行切换  「两个过渡一共有6个class切换」



## enter过渡

- 初始帧  添加v-enter   class 
- 过渡帧 添加v-enter-active  
  - 理解 : 故意添加一帧 , 防止动画帧太少 , 过渡效果太僵硬
- 结尾帧  添加v-enter-to 



过渡执行到对应帧的时候 , 会默认添加class 



## leave过渡

和enter过渡一样 , 只是class类名v-enter 换成 v-leave

这也暗示了 : 自定义class类名的修改策略





## 过渡的class类名

<transition>的name属性  

 name = “自定义class类名”



- 直接暴力修改

```html
<transition enter-active-class = "xxx" leave-active-class="yyy">
```

把自动添加的class类名 , 修改成任意想写的



## 动画

- enter过渡的结尾帧 , 恰好是leave过渡的初始帧 , 反之 , leave的结尾帧恰好是enter的初始帧
  - 因此在动画中 , 因此只用写v-enter 和 v-leave
  - v-enter-to 和 v-leave-to 可以省去不写



