# 作用

> 用来匹配符合某种规则的字符串 , **字符串匹配**
>
> 是一个对象



# 创建

## 字面量方式创建

```js
let reg = /+86\d{11}/g 
```



## 构造函数方式创建

麻烦，但正则规则可通过字符串拼接，有些场景不得不用

```js
let reg = new RegExp('+86\d{11}','g')
```

## 修饰符

| 修饰符 | 含义       |
| ------ | ---------- |
| g      | 全局搜索   |
| i      | 忽略大小写 |
| m      | 多行搜索   |



# 常用方法

## test()  

   作用: 检查字符串是否符合正则对象的规则

```js
let reg = /+86\d{11}/g 
reg.test(`+863i2794723`)
```



## 字符串的方法

> 正则对象作为字符串方法的参数 , 对字符串进行验证

| 方法                 | 说明                                 |
| -------------------- | ------------------------------------ |
| search(reg)          | 判断字符串是否匹配                   |
| match(reg)           | 返回一个数组 ， 里面放着匹配的字符串 |
| replace（reg , str） | 用str 替换掉匹配规则的字符串         |
| split(reg)           | 返回一个数组 , 里面放着字符串切片    |





# 专用字符

| 字符   | 含义                                                  |
| ------ | ----------------------------------------------------- |
| .      | 匹配除了空格和回车的任意字符  <==>`[^\r\n]`           |
| /xxxx/ | 字符匹配                                              |
| [xxx]  | 范围匹配 : 匹配范围内的一个字符   [0-9]  or  [a-zA-Z] |
| [^]    | 不是 ==> 取反                                         |
| \d     | 匹配一个数字字符   <==>  [0-9]                        |
| \D     | <==> `[^0-9]`                                         |
| \s     | 匹配一个空格                                          |
| \S     | 匹配非空格                                            |
| \w     | <==>  [a-zA-Z_0-9]                                    |





# 量词

> 匹配多个字符

| 量词  | 作用                                       |
| ----- | ------------------------------------------ |
| ?     | 前面的字符出现0次或者1次   ==>有没有都可以 |
| +     | 前的字符 : 必须有 , 有多少次无所谓         |
| *     | 前面的字符 : 0次  or n次                   |
| {n}   | 前面的字符出现n次                          |
| {n,m} | q前面的字符出现n到m次                      |
| {n,}  | 至少出现n次                                |
|       |                                            |



# 边界区分

> 以 xxx 开头  或者 以xxx结尾

| 正则      | 含义              |
| --------- | ----------------- |
| /^xxx/    | 以xxx开头         |
| /xxx$/    | 以xxx结尾         |
| /\bxxx\b/ | 匹配是单词的xxx   |
| /\Bxxx\B/ | 匹配不是单词的xxx |
|           |                   |
|           |                   |
|           |                   |



# 常用正则

## 匹配手机号

```js
let reg = /^1\d{10}$/
```

## 匹配邮箱

```js
let reg=/^[^@\s]+@[^@\s]+\.[^@\s]+$/
```

## 匹配用户名

```js

```





# 贪婪模式和非贪婪模式

> 默认是贪婪模式
>
> 在量词情况下{n.m} , 究竟选n匹配还是选m匹配??
>
> 默认是选m匹配 ,

{n,m}?  开启非贪婪模式 , 选n匹配

```js
let s = '123456789'
s.match(/\d{3,5}/g)
s.match(/\d{3,5}?/g)
```

## 实用举例

```js
`aa"helloworld"ok"jirengu"`.match(/".+"/g)
```

> 贪婪 

会尽可能匹配 , 得到一个数组

`[""helloworld"ok"jirengu""]`

这不是我们希望的 , 我们希望得到["helloworld", "jirengu"]

> 非贪婪

```js
`aa"helloworld"ok"jirengu"`.match(/".+?"/g)
```

`["helloworld", "jirengu"]`





# 分组

```js
(xxx){3}   
```

(xx) 被这些字符看撑一个整体去匹配

$n 来引用!!





# 前瞻

格式:

```js
exp1(?=exp2)  匹配后面是exp2的exp1
exp1(?exp2)   匹配后面不是exp2的 exp1
```



如:

```js
/hello(?=jirengu)/.test('hellojirengu') //true
```



